!Cascading Style Sheets with RenoirSt

RenoirST is a DSL enabling programmatic cascading style sheet generation for Pharo developed by Gabriel Omar Cotelli.

The goals of RenoirST are to improve CSS integration with existing web frameworks
and to be able to write and refactor code in Pharo and deploy to CSS. Renoir features are:
common properties declaration, CSS3 selector support, important rules and media queries support.
In this tutorial we will present the key features of RenoirSt with a large set of examples.
This tutorial assumes some knowledge of CSS and Pharo Smalltalk. For a little introduction about CSS you can read the *Seaside's book CSS chapter>http://book.seaside.st/book/fundamentals/css*.

!!Getting started

To load the library in your image, evaluate:

[[[
Gofer it
  url: 'http://smalltalkhub.com/mc/gcotelli/RenoirSt/main';
  configurationOf: 'RenoirSt';
  loadStable
]]]

or download a ready to use image from the *Pharo contribution CI Server>https://ci.inria.fr/pharo-contribution/job/RenoirSt*.


The main entry point for the library is the class ==CascadingStyleSheetBuilder==. In a workspace, inspect the result of the following expression:

[[[
CascadingStyleSheetBuilder new build
]]]

You now have an inspector on your first (empty and useless) style sheet. Real stylesheets are composed of rules (or rule-sets), where each one has a selector and a declaration group. The selector determines if the rule applies to some element in the DOM, and the declaration group specifies the style to apply.

Our first useful style sheet will simply assign a margin to every div element in the DOM.

[[[
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style margin: 2 px ];
  build
]]]

the expected result in CSS is:

[[[
div
{
  margin: 2px;
}
]]]

The message ==declareRuleSetFor:with:== is used to configure a rule-set in the builder. The message requires two blocks: the first block defines the selector and the second defines the style to apply to elements matching the selector. The ==selector== argument of the first block is an entry point to construct the selector (more on this later). The ==style== argument of the second block is an entry point to declare CSS properties and values.

The properties API is mostly defined following this rules:

- Properties without dashes in the name are directly mapped: the margin CSS property is mapped to a ==margin:== message send.
- Properties with one or more dashes are mapped using camel case: the margin-top CSS property is mapped to the ==marginTop:== message send.

!!Defining the selectors

!!Defining the rules

We now present how the various CSS rules can be expressed with RenoirSt. RenoirSt supports many CSS types, comments, and even functional notation.

!!!Basic CSS Types

!!!!Lengths, Angles, Times and Frequencies

The library provides out-of-the-box support for the length, angle, time and frequency units in the CSS spec. There are extensions for ==Integer== and ==Float== classes allowing to obtain lengths.

The supported length units are:
- ==em== relative to font size
- ==ex== relative to "x" height
- ==ch== relative to width of the zero glyph in the element's font
- ==rem== relative to font size of root element
- ==vw== 1% of viewport's width
- ==vh== 1% of viewport's height
- ==vmin== 1% of viewport's smaller dimension
- ==vmax== 1% of viewport's larger dimension
- ==cm== centimeters
- ==mm== millimeteres
- ==in== inches
- ==pc== picas
- ==pt== points
- ==px== pixels (note that CSS has some special definition for pixel)

The supported angle units are:
- ==deg== degrees
- ==grad== gradians
- ==rad== radians
- ==turn== turns

The supported time units are:
- ==s== seconds
- ==ms== milliseconds

The supported frequency units are:
- ==Hz== Hertz
- ==kHz== KiloHertz

RenoirST also supports the creation of percentages: ==50 percent== is mapped to ==50%== in the resulting CSS.

Some properties require integer or floating point values. In these cases just use the standard Pharo integer and float support. For example:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style zIndex: 2 ];
  build
]]]

!!!!Colors

The library supports abstractions for properties requiring color values. The shared pool ==CssSVGColors== provides easy access to colors in the SVG 1.0 list, and the abstractions ==CssRGBColor== and ==CssHSLColor== allow the creation of colors in the RGB and HSL spaces including alpha support.


For example,

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style |
    style
      backgroundColor: CssSVGColors aliceBlue;
      borderColor: (CssRGBColor red: 0 green: 128 blue: 0 alpha: 0.5)];
  build
]]]

evaluates to:

[[[language=css
div
{
    background-color: aliceblue;
    border-color: rgba(0,128,0,0.5);
}
]]]

@@note In a real scenario you should avoid hard coding colors as in the examples. It is recommended to put colors in objects representing a theme or something that gives them a name related to your application.

RGB-Colors also support percentage values:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style |
    style borderColor: (CssRGBColor red: 0 percent green: 50 percent blue: 0 percent) ];
  build
]]]

evaluates to:

[[[language=css
div
{
    border-color: rgb(0%,50%,0%);

}
]]]

Notice the difference in the used message because there is no alpha channel specification.

!!!!Constants

A lot of values for CSS properties are just keyword constants. This support is provided by the classes ==CssConstants== and ==CssFontConstants==.

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style textAlign: CssConstants justify ];
  build
]]]

evaluates to:

[[[language=css
div
{
    text-align: justify;
}
]]]

!!!!Several Property Values

Some properties support a wide range of values. For example the ==margin== property can have 1, 2 , 3 or 4 values specified. If you only need one value, just pass it as a parameter. For more than one value, use an array:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style margin: { 2 px. 4 px } ];
  build
]]]

evaluates to:

[[[language=css
div
{
    margin: 2px 4px;
}
]]]

!!!!URLs

==ZnUrl== instances can be used as the value for properties requiring an URI. Both relative and absolute URLs are accepted.

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div class: 'logo' ]
  with: [ :style | style backgroundImage: 'images/logo.png' asZnUrl ];
  declareRuleSetFor: [ :selector | selector div class: 'logo' ]
  with: [ :style | style backgroundImage: 'http://www.example.com/images/logo.png' asZnUrl ];
  build
]]]
Evaluates to:
[[[language=css
div.logo
{
    background-image: url("images/logo.png");
}

div.logo
{
    background-image: url("http://www.example.com/images/logo.png");
}
]]]

!!!Comments

When declaring rule sets, the library supports attaching comments to them with the ==declareRuleSetFor:with:andComment:== message:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style margin: 2 pc ]
  andComment: 'Two picas margin';
  build
]]]

evaluates to:

[[[language=css
/*Two picas margin*/
div
{
    margin: 2pc;
}
]]]

RenoirST also supports defining stand-alone comments (not attached to any rule):

[[[language=smalltalk
CascadingStyleSheetBuilder new
  comment: 'A general comment';
  build
]]]

evaluates to:

[[[language=css
/*A general comment*/
]]]

!!!Functional Notation

A functional notation is a type of CSS component value that can represent complex types or invoke special processing. The mathematical expressions, toggling between values, attribute references, and gradients are all supported in RenoirST.

!!!!Mathematical Expressions

The library provides support for math expressions using the  ==CssMathExpression== abstraction. This math expressions are built instantiating a ==CssMathExpression== with the first operand, and sending to it ==+==, ==-==, ==*== or ==/== messages. Lets see some example:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style margin: (CssMathExpression on: 2 pc) / 3 + 2 percent ];
  build
]]]
Evaluates to:
[[[language=css
div
{
    margin: calc(2pc / 3 + 2%);
}
]]]

!!!!Toggling Between Values

This kind of expressions allows descendant elements to cycle over a list of values instead of inheriting the same value. It's supported using the ==CssToggle== abstraction.

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector unorderedList unorderedList ]
  with: [ :style | style listStyleType: (CssToggle cyclingOver: { CssConstants disc. CssConstants circle. CssConstants square}) ];
  build
]]]
Evaluates to:
[[[language=css
ul ul
{
    list-style-type: toggle(disc, circle, square);
}
]]]

!!!!Attribute References

The attr() function is allowed as a component value in properties applied to an element or pseudo-element. It returns the value of an attribute on the element. If used on a pseudo-element, it returns the value of the attribute on the pseudo-element's originating element. It's supported using the ==CssAttributeReference== abstraction. This function can be used simply providing an attribute name:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div before ]
  with: [ :style | style content: (CssAttributeReference toAttributeNamed: 'title') ];
  build
]]]
Evaluates to:
[[[language=css
div::before
{
    content: attr(title string);
}
]]]
or providing also the type or unit of the attribute (if no type or unit is specified the ==string== type is assumed):

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div  ]
  with: [ :style | style width: (CssAttributeReference toAttributeNamed: 'height' ofType: CssLengthUnits pixels) ];
  build
]]]
Evaluates to:
[[[language=css
div
{
    width: attr(height px);
}
]]]

also it's possible to provide a fallback value in case the attribute is not present:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div before ]
  with: [ :style | style content: (CssAttributeReference toAttributeNamed: 'title' ofType: 'string' withFallback: '"Missing title"') ];
  build
]]]
Evaluates to:
[[[language=css
div::before
{
    content: attr(title string, "Missing title");
}
]]]

!!!!Gradients

A gradient is an image that smoothly fades from one color to another. These are commonly used for subtle shading in background images, buttons, and many other things. The gradient notations described in this section allow an author to specify such an image in a terse syntax, so that the UA can generate the image automatically when rendering the page. This notation is supported using ==CssLinearGradient== and ==CssRadialGradient== asbtractions.

Let's see some examples for linear gradients:

[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssLinearGradient fading: { CssSVGColors yellow. CssSVGColors blue }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssLinearGradient to: CssConstants bottom fading: { CssSVGColors yellow. CssSVGColors blue }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssLinearGradient rotated: 45 deg fading: { CssSVGColors yellow. CssSVGColors blue }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssLinearGradient rotated: 90 deg fading: { CssSVGColors yellow. (CssColorStop for: CssSVGColors blue at: 30 percent) }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssLinearGradient fading: { CssSVGColors yellow. (CssColorStop for: CssSVGColors blue at: 20 percent). CssSVGColors green}) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssLinearGradient to: { CssConstants top. CssConstants right } fading: { CssSVGColors red.  CssSVGColors white. CssSVGColors blue }) ];
  build
]]]

evaluates to:

[[[language=css
div
{
    background: linear-gradient(yellow, blue);
}

div
{
    background: linear-gradient(to bottom, yellow, blue);
}

div
{
    background: linear-gradient(45deg, yellow, blue);
}

div
{
    background: linear-gradient(90deg, yellow, blue 30%);
}

div
{
    background: linear-gradient(yellow, blue 20%, green);
}

div
{
    background: linear-gradient(to top right, red, white, blue);
}
]]]

and some for radial gradients:
[[[language=smalltalk
CascadingStyleSheetBuilder new
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssRadialGradient fading: { CssSVGColors yellow. CssSVGColors green }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssRadialGradient elliptical: CssConstants farthestCorner at: CssConstants center fading: { CssSVGColors yellow. CssSVGColors green }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssRadialGradient elliptical: CssConstants farthestSide at: { CssConstants left. CssConstants bottom} fading: { CssSVGColors red. (CssColorStop for: CssSVGColors yellow at: 50 px). CssSVGColors green }) ];
  declareRuleSetFor: [ :selector | selector div ]
  with: [ :style | style background: (CssRadialGradient elliptical: {20 px. 30 px} at: { 20 px. 30 px} fading: { CssSVGColors red. CssSVGColors yellow. CssSVGColors green }) ];
  build
]]]
evaluates to:
[[[language=css
div
{
    background: radial-gradient(yellow, green);
}

div
{
    background: radial-gradient(farthest-corner ellipse at center, yellow, green);
}

div
{
    background: radial-gradient(farthest-side ellipse at left bottom, red, yellow 50px, green);
}

div
{
    background: radial-gradient(20px 30px ellipse at 20px 30px, red, yellow, green);
}
]]]

To make the gradient repeatable, just send to it the message ==beRepeating==. For Example:
[[[language=smalltalk
(CssRadialGradient fading: { CssSVGColors yellow. CssSVGColors green }) beRepeating
]]]
renders as:
[[[language=css
repeating-radial-gradient(yellow, green);
]]]
